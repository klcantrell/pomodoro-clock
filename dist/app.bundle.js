(function(e){function t(s){if(r[s])return r[s].exports;var n=r[s]={i:s,l:!1,exports:{}};return e[s].call(n.exports,n,n.exports,t),n.l=!0,n.exports}var r={};return t.m=e,t.c=r,t.d=function(e,r,s){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:s})},t.r=function(e){Object.defineProperty(e,'__esModule',{value:!0})},t.n=function(e){var r=e&&e.__esModule?function(){return e['default']}:function(){return e};return t.d(r,'a',r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p='',t(t.s='./src/js/index.js')})({"./node_modules/kute.js/kute-attr.js":/*!*******************************************!*\
  !*** ./node_modules/kute.js/kute-attr.js ***!
  \*******************************************//*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* KUTE.js - The Light Tweening Engine\r\n * package - Attributes Plugin\r\n * desc - enables animation for color attributes and any numeric presentation attribute\r\n * by dnp_theme\r\n * Licensed under MIT-License\r\n */\r\n\r\n(function (root,factory) {\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kute.js */ "./node_modules/kute.js/kute.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n  } else {}\r\n}(this, function (KUTE) {\r\n  \'use strict\';\r\n\r\n  var g = typeof global !== \'undefined\' ? global : window, // connect to KUTE object and global\r\n    K = KUTE, DOM = K.dom, prepareStart = K.prepareStart, parseProperty = K.parseProperty,\r\n    trueColor = K.truC, trueDimension = K.truD, crossCheck = K.crossCheck,\r\n    unit = g.Interpolate.unit, number = g.Interpolate.number, color = g.Interpolate.color;\r\n\r\n  // here we go with the plugin\r\n  var getCurrentValue = function(e,a){ return e.getAttribute(a); }, // get current attribute value\r\n    svgColors = [\'fill\',\'stroke\',\'stop-color\'], attributes,\r\n    replaceUppercase = function(a) {\r\n      return a.replace(/[A-Z]/g, "-$&").toLowerCase();\r\n    };\r\n\r\n  prepareStart.attr = function(p,v){\r\n    var attrStartValues = {};\r\n    for (var a in v){\r\n      var attribute = replaceUppercase(a).replace(/_+[a-z]+/,\'\'),\r\n        currentValue = getCurrentValue(this.element,attribute); // get the value for \'fill-opacity\' not fillOpacity\r\n      attrStartValues[attribute] = svgColors.indexOf(attribute) !== -1 ? (currentValue || \'rgba(0,0,0,0)\') : (currentValue || (/opacity/i.test(a) ? 1 : 0));\r\n    }\r\n    return attrStartValues;\r\n  };\r\n\r\n  // process attributes object K.pp.attr(t[x])\r\n  // and also register their render functions\r\n  parseProperty.attr = function(a,o){\r\n    if (!(\'attr\' in DOM)) {\r\n      DOM.attr = function(l,p,a,b,v) {\r\n        for ( var o in b ){\r\n          DOM.attributes[o](l,o,a[o],b[o],v);\r\n        }\r\n      }\r\n      attributes = DOM.attributes = {}\r\n    }\r\n\r\n    var attributesObject = {};\r\n    for ( var p in o ) {\r\n      var prop = replaceUppercase(p), regex = /(%|[a-z]+)$/, cv = getCurrentValue(this.element,prop.replace(/_+[a-z]+/,\'\'));\r\n      if ( svgColors.indexOf(prop) === -1) {\r\n        if ( cv !== null && regex.test(cv) ) {\r\n          var prefix = trueDimension(cv).u || trueDimension(o[p]).u, s = /%/.test(prefix) ? \'_percent\' : \'_\'+prefix;\r\n          if (!(prop+s in attributes)) {\r\n            if (/%/.test(prefix)) {\r\n              attributes[prop+s] = function(l,p,a,b,v) {\r\n                var _p = _p || p.replace(s,\'\');\r\n                l.setAttribute(_p, ((number(a.v,b.v,v) * 1000>>0)/1000) + b.u );\r\n              }\r\n            } else {\r\n              attributes[prop+s] = function(l,p,a,b,v) {\r\n                var _p = _p || p.replace(s,\'\');\r\n                l.setAttribute(_p, ( (number(a.v,b.v,v)*1000>>0)/1000) + b.u );\r\n              }\r\n            }\r\n          }\r\n          attributesObject[prop+s] = trueDimension(o[p]);\r\n        } else if ( !regex.test(o[p]) || cv === null || cv !== null && !regex.test(cv) ) {\r\n          if (!(prop in attributes)) {\r\n            if (/opacity/i.test(p)) {\r\n              attributes[prop] = function(l,o,a,b,v) {\r\n                l.setAttribute(o, (number(a,b,v) * 1000 >> 0) / 1000 );\r\n              }\r\n            } else {\r\n              attributes[prop] = function(l,o,a,b,v) {\r\n                l.setAttribute(o, (number(a,b,v) * 1000 >> 0) / 1000 );\r\n              }\r\n            }\r\n          }\r\n          attributesObject[prop] = parseFloat(o[p]);\r\n        }\r\n      } else {\r\n        if (!(prop in attributes)) {\r\n          attributes[prop] = function(l,u,a,b,v) {\r\n            l.setAttribute(u, color(a,b,v,o.keepHex));\r\n          }\r\n        }\r\n        attributesObject[prop] = trueColor(o[p]);\r\n      }\r\n    }\r\n    return attributesObject;\r\n  }\r\n\r\n  return this;\r\n}));\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:///./node_modules/kute.js/kute-attr.js?')},"./node_modules/kute.js/kute-svg.js":/*!******************************************!*\
  !*** ./node_modules/kute.js/kute-svg.js ***!
  \******************************************//*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* KUTE.js - The Light Tweening Engine\r\n * package - SVG Plugin\r\n * desc - draw SVG strokes, morph SVG and SVG transforms\r\n * by dnp_theme\r\n * Licensed under MIT-License\r\n */\r\n\r\n(function (root,factory) {\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kute.js */ "./node_modules/kute.js/kute.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n  } else {}\r\n}(this, function(KUTE) {\r\n  \'use strict\';\r\n\r\n  var g = typeof global !== \'undefined\' ? global : window, K = KUTE, // connect plugin to KUTE object and global\r\n    DOM = K.dom, parseProperty = K.parseProperty, prepareStart = K.prepareStart, getCurrentStyle = K.getCurrentStyle,\r\n    trueColor = K.truC, trueDimension = K.truD, crossCheck = K.crossCheck,\r\n    number = g.Interpolate.number, unit = g.Interpolate.unit, color = g.Interpolate.color, // interpolate functions\r\n    defaultOptions = K.defaultOptions, // default tween options since 1.6.1\r\n\r\n    // browser detection\r\n    isIE = new RegExp("MSIE ([0-9]{1,}[\\.0-9]{0,})").exec(navigator.userAgent) !== null ? parseFloat( RegExp.$1 ) : false;\r\n\r\n  if (isIE&&isIE<9) {return;} // return if SVG API is not supported\r\n\r\n  // here we go with the plugin\r\n  var pathReg = /(m[^(h|v|l)]*|[vhl][^(v|h|l|z)]*)/gmi, ns = \'http://www.w3.org/2000/svg\',\r\n    // function(array1, array2, length, progress) for SVG morph\r\n    coords = g.Interpolate.coords = function(a,b,l,v) {\r\n      var points = [];\r\n      for(var i=0;i<l;i++) { // for each point\r\n        points[i] = [];\r\n        for(var j=0;j<2;j++) { // each point coordinate\r\n          points[i].push( ((a[i][j]+(b[i][j]-a[i][j])*v) * 1000 >> 0)/1000 );\r\n        }\r\n      }\r\n      return points;\r\n    };\r\n\r\n\r\n  // SVG MORPH\r\n  var getSegments = function(s,e,r){ // getSegments returns an array of points based on a sample size morphPrecision\r\n      var s1 = [], e1 = [], le1 = s.getTotalLength(), le2 = e.getTotalLength(), ml = Math.max(le1,le2),\r\n        d = r, ar = ml / r, j = 0, sl = ar*r; // sl = sample length\r\n\r\n      while ( (j += r) < sl ) { // populate the points arrays based on morphPrecision as sample size\r\n        s1.push( [s.getPointAtLength(j).x, s.getPointAtLength(j).y]);\r\n        e1.push( [e.getPointAtLength(j).x, e.getPointAtLength(j).y]);\r\n      }\r\n      return [s1,e1];\r\n    },\r\n    getClosestPoint = function(p,t,s){ // utility for polygon paths, returns a close point from the original path (length,pointAtLength,smallest); // intervalLength\r\n      var x, y, a = [], l = s.length, dx, nx, pr;\r\n      for (var i=0; i<l; i++){\r\n        x = Math.abs(s[i][0] - t.x);\r\n        y = Math.abs(s[i][1] - t.y);\r\n        a.push( Math.sqrt( x * x + y * y ) );\r\n      }\r\n      dx = a.indexOf(Math.min.apply(null,a));\r\n      pr = !!s[dx-1] ? dx-1 : l-1;\r\n      nx = !!s[dx+1] ? dx+1 : 0;\r\n      return Math.abs(s[pr][0] - t.x) < p && Math.abs(s[pr][1] - t.y) < p ? s[pr]\r\n      : Math.abs(s[nx][0] - t.x) < p && Math.abs(s[nx][1] - t.y) < p ? s[nx]\r\n      : Math.abs(s[dx][0] - t.x) < p && Math.abs(s[dx][1] - t.y) < p ? s[dx]\r\n      : [t.x,t.y];\r\n    },\r\n    pathToAbsolute = function(p) { // simple utility for polygons | this is still BETA / a work in progress\r\n      var np = p.match(pathReg), wp = [], l = np.length, s, c, r, x = 0, y = 0;\r\n      for (var i = 0; i<l; i++){\r\n        np[i] = np[i]; c = np[i][0]; r = new RegExp(c+\'[^\\\\d|\\\\-]*\',\'i\');\r\n        np[i] = np[i].replace(/(^|[^,])\\s*-/g, \'$1,-\').replace(/(\\s+\\,|\\s|\\,)/g,\',\').replace(r,\'\').split(\',\');\r\n        np[i][0] = parseFloat(np[i][0]);\r\n        np[i][1] = parseFloat(np[i][1]);\r\n        if (i === 0) { x+=np[i][0]; y +=np[i][1]; }\r\n        else {\r\n          x = np[i-1][0];\r\n          y = np[i-1][1];\r\n          if (/l/i.test(c)) {\r\n            np[i][0] = c === \'l\' ? np[i][0] + x : np[i][0];\r\n            np[i][1] = c === \'l\' ? np[i][1] + y : np[i][1];\r\n          } else if (/h/i.test(c)) {\r\n            np[i][0] = c === \'h\' ? np[i][0] + x : np[i][0];\r\n            np[i][1] = y;\r\n          } else if (/v/i.test(c)) {\r\n            np[i][0] = x;\r\n            np[i][1] = c === \'v\' ? np[i][0] + y : np[i][0];\r\n          }\r\n        }\r\n      }\r\n      return np;\r\n    },\r\n    getOnePath = function(p){ return p.split(/z/i).shift() + \'z\'; }, // we only tween first path only\r\n    createPath = function (p){ // create a <path> when glyph\r\n      var createdPath = document.createElementNS(ns,\'path\'), d = typeof p === \'object\' ? p.getAttribute(\'d\') : p;\r\n      createdPath.setAttribute(\'d\',d); return createdPath;\r\n    },\r\n    forcePath = function(p){ // forcePath for glyph elements\r\n      if (p.tagName === \'glyph\') { // perhaps we can also change other SVG tags in the future\r\n        var c = createPath(p); p.parentNode.appendChild(c); return c;\r\n      }\r\n      return p;\r\n    },\r\n    clone = function(a) {\r\n      var copy;\r\n      if (a instanceof Array) {\r\n        copy = [];\r\n        for (var i = 0, len = a.length; i < len; i++) {\r\n          copy[i] = clone(a[i]);\r\n        }\r\n        return copy;\r\n      }\r\n      return a;\r\n    },\r\n    getPath = function(e){ // get path d attribute or create a path from string value\r\n      var p = {}, el = typeof e === \'object\' ? e : /^\\.|^\\#/.test(e) ? document.querySelector(e) : null;\r\n      if ( el && /path|glyph/.test(el.tagName) ) {\r\n        p.e = forcePath(el);\r\n        p.o = el.getAttribute(\'d\');\r\n\r\n      } else if (!el && /[a-z][^a-z]*/ig.test(e)) { // maybe it\'s a string path already\r\n        p.e = createPath(e.trim());\r\n        p.o = e;\r\n      }\r\n      return p;\r\n    },\r\n    computePathCross = function(s,e){ // pathCross\r\n      var s1, e1, pointsArray, largerPathLength, smallerPath, largerPath, simulatedSmallerPath, nsm = [], sml, cl = [], len, tl, cs,\r\n        index = this.options.morphIndex;\r\n\r\n      if (!this._isPolygon) {\r\n        s = createPath(s); e = createPath(e);\r\n        pointsArray = getSegments(s,e,this.options.morphPrecision);\r\n        s1 = pointsArray[0]; e1 = pointsArray[1]; largerPathLength = e1.length;\r\n      } else {\r\n        s = pathToAbsolute(s); e = pathToAbsolute(e);\r\n\r\n        if ( s.length !== e.length ){\r\n          largerPathLength = Math.max(s.length,e.length);\r\n          if ( largerPathLength === e.length) { smallerPath = s; largerPath = e; } else { smallerPath = e; largerPath = s; }\r\n          sml = smallerPath.length;\r\n\r\n          simulatedSmallerPath = createPath(\'M\'+smallerPath.join(\'L\')+\'z\'); len = simulatedSmallerPath.getTotalLength() / largerPathLength;\r\n          for (var i=0; i<largerPathLength; i++){\r\n            tl = simulatedSmallerPath.getPointAtLength(len*i);\r\n            cs = getClosestPoint(len,tl,smallerPath);\r\n            nsm.push( [ cs[0], cs[1] ] );\r\n          }\r\n\r\n          if (largerPathLength === e.length) { e1 = largerPath; s1 = nsm; } else { s1 = largerPath; e1 = nsm; }\r\n        } else {\r\n          s1 = s; e1 = e;\r\n        }\r\n      }\r\n\r\n      // reverse arrays\r\n      if (this.options.reverseFirstPath) { s1.reverse(); }\r\n      if (this.options.reverseSecondPath) { e1.reverse(); }\r\n\r\n      // shift second array to for smallest tween distance\r\n      if (index) {\r\n        var e11 = e1.splice(index,largerPathLength-index);\r\n        e1 = e11.concat(e1);\r\n      }\r\n\r\n      s = e = null;\r\n      return [s1,e1]\r\n    };\r\n\r\n  // set default morphPrecision since 1.6.1\r\n  defaultOptions.morphPrecision = 15;\r\n\r\n  // process path object and also register the render function\r\n  parseProperty.path = function(o,v) {\r\n    if (!(\'path\' in DOM)) {\r\n      DOM.path = function(l,p,a,b,v){\r\n        l.setAttribute("d", v === 1 ? b.o : \'M\' + coords( a[\'d\'],b[\'d\'],b[\'d\'].length,v ) + \'Z\' );\r\n      }\r\n    }\r\n    return getPath(v);\r\n  };\r\n\r\n  prepareStart.path = function(p){\r\n    return this.element.getAttribute(\'d\');\r\n  };\r\n\r\n  crossCheck.path = function() { // unlike other cases, the crossCheck apply to both to() and fromTo() methods\r\n    var p1 = getOnePath(this.valuesStart.path.o), p2 = getOnePath(this.valuesEnd.path.o), paths;\r\n\r\n    // path tween options\r\n    this.options.morphPrecision = this.options && \'morphPrecision\' in this.options ? parseInt(this.options.morphPrecision) : defaultOptions.morphPrecision;\r\n    this._isPolygon = !/[CSQTA]/i.test(p1) && !/[CSQTA]/i.test(p2); // check if both shapes are polygons\r\n\r\n    // begin processing paths\r\n    paths = computePathCross.apply(this,[p1,p2]);\r\n\r\n    this.valuesStart.path.d = paths[0];\r\n    this.valuesEnd.path.d = paths[1];\r\n  };\r\n\r\n\r\n  // SVG DRAW\r\n  var percent = function(v,l){ return parseFloat(v) / 100 * l; },\r\n    // SVG DRAW UTILITITES\r\n    // http://stackoverflow.com/a/30376660\r\n    getRectLength = function(el){ // returns the length of a Rect\r\n      var w = el.getAttribute(\'width\');\r\n      var h = el.getAttribute(\'height\');\r\n      return (w*2)+(h*2);\r\n    },\r\n    getPolyLength = function(el){ // getPolygonLength / getPolylineLength - return the length of the Polygon / Polyline\r\n      var points = el.getAttribute(\'points\').split(\' \'), len = 0;\r\n      if (points.length > 1) {\r\n        var coord = function (p) {\r\n          var c = p.split(\',\');\r\n          if (c.length != 2) { return; } // return undefined\r\n          if (isNaN(c[0]) || isNaN(c[1])) { return; }\r\n          return [parseFloat(c[0]), parseFloat(c[1])];\r\n        };\r\n\r\n        var dist = function (c1, c2) {\r\n          if (c1 != undefined && c2 != undefined) {\r\n            return Math.sqrt(Math.pow((c2[0]-c1[0]), 2) + Math.pow((c2[1]-c1[1]), 2));\r\n          }\r\n          return 0;\r\n        };\r\n\r\n        if (points.length > 2) {\r\n          for (var i=0; i<points.length-1; i++) {\r\n            len += dist(coord(points[i]), coord(points[i+1]));\r\n          }\r\n        }\r\n        len += dist(coord(points[0]), coord(points[points.length-1]));\r\n      }\r\n      return len;\r\n    },\r\n    getLineLength = function(el){ // return the length of the line\r\n      var x1 = el.getAttribute(\'x1\');\r\n      var x2 = el.getAttribute(\'x2\');\r\n      var y1 = el.getAttribute(\'y1\');\r\n      var y2 = el.getAttribute(\'y2\');\r\n      return Math.sqrt(Math.pow((x2-x1), 2)+Math.pow((y2-y1),2));\r\n    },\r\n    getCircleLength = function(el){ // return the length of the circle\r\n      var r = el.getAttribute(\'r\');\r\n      return 2 * Math.PI * r;\r\n    },\r\n    getEllipseLength = function(el) { // returns the length of an ellipse\r\n      var rx = el.getAttribute(\'rx\'), ry = el.getAttribute(\'ry\'),\r\n          len = 2*rx, wid = 2*ry;\r\n      return ((Math.sqrt(.5 * ((len * len) + (wid * wid)))) * (Math.PI * 2)) / 2;\r\n    },\r\n    getTotalLength = function(el){ // returns the result of any of the below functions\r\n      if (/rect/.test(el.tagName)) {\r\n        return getRectLength(el);\r\n      } else if (/circle/.test(el.tagName)) {\r\n        return getCircleLength(el);\r\n      } else if (/ellipse/.test(el.tagName)) {\r\n        return getEllipseLength(el);\r\n      } else if (/polygon|polyline/.test(el.tagName)) {\r\n        return getPolyLength(el);\r\n      } else if (/line/.test(el.tagName)) {\r\n        return getLineLength(el);\r\n      }\r\n    },\r\n    getDraw = function(e,v){\r\n      var l = /path|glyph/.test(e.tagName) ? e.getTotalLength() : getTotalLength(e), start, end, d, o;\r\n      if ( v instanceof Object ) {\r\n        return v;\r\n      } else if (typeof v === \'string\') {\r\n        v = v.split(/\\,|\\s/);\r\n        start = /%/.test(v[0]) ? percent(v[0].trim(),l) : parseFloat(v[0]);\r\n        end = /%/.test(v[1]) ? percent(v[1].trim(),l) : parseFloat(v[1]);\r\n      } else if (typeof v === \'undefined\') {\r\n        o = parseFloat(getCurrentStyle(e,\'stroke-dashoffset\'));\r\n        d = getCurrentStyle(e,\'stroke-dasharray\').split(/\\,/);\r\n\r\n        start = 0-o;\r\n        end = parseFloat(d[0]) + start || l;\r\n      }\r\n      return { s: start, e: end, l: l }\r\n    };\r\n\r\n  parseProperty.draw = function(a,o){ // register the draw property\r\n    if (!(\'draw\' in DOM)) {\r\n      DOM.draw = function(l,p,a,b,v){\r\n        var pathLength = (a.l*100>>0)/100, start = (number(a.s,b.s,v)*100>>0)/100, end = (number(a.e,b.e,v)*100>>0)/100,\r\n        offset = 0 - start, dashOne = end+offset;\r\n        l.style.strokeDashoffset = offset +\'px\';\r\n        l.style.strokeDasharray = (((dashOne <1 ? 0 : dashOne)*100>>0)/100) + \'px, \' + pathLength + \'px\';\r\n      }\r\n    }\r\n    return getDraw(this.element,o);\r\n  }\r\n\r\n  prepareStart.draw = function(){\r\n    return getDraw(this.element);\r\n  }\r\n\r\n\r\n  // SVG Transform\r\n  var parseStringOrigin = function(origin,box){\r\n      return /[a-zA-Z]/.test(origin) && !/px/.test(origin) ? origin.replace(/top|left/,0).replace(/right|bottom/,100).replace(/center|middle/,50)\r\n                                     : /%/.test(origin) ? (box.x + parseFloat(origin) * box.width / 100) : parseFloat(origin);\r\n    },\r\n    parseTransformString = function (a){ // helper function that turns transform value from string to object\r\n      var d = a && /\\)/.test(a) ? a.substring(0, a.length-1).split(/\\)\\s|\\)/) : \'none\', c = {};\r\n\r\n      if (d instanceof Array) {\r\n        for (var j=0, jl = d.length; j<jl; j++){\r\n          var p = d[j].trim().split(\'(\'); c[p[0]] = p[1];\r\n        }\r\n      }\r\n      return c;\r\n    },\r\n    parseTransformObject = function(v){\r\n      var svgTransformObject = {}, bb = this.element.getBBox(),\r\n        cx = bb.x + bb.width/2, cy = bb.y + bb.height/2, // by default the transformOrigin is "50% 50%" of the shape box\r\n        origin = this.options.transformOrigin, translation;\r\n\r\n      origin = !!origin ? (origin instanceof Array ? origin : origin.split(/\\s/)) : [cx,cy];\r\n\r\n      origin[0] = typeof origin[0] === \'number\' ? origin[0] : parseStringOrigin(origin[0],bb);\r\n      origin[1] = typeof origin[1] === \'number\' ? origin[1] : parseStringOrigin(origin[1],bb);\r\n\r\n      svgTransformObject.origin = origin;\r\n\r\n      for ( var i in v ) { // populate the valuesStart and / or valuesEnd\r\n        if (i === \'rotate\'){\r\n          svgTransformObject[i] = typeof v[i] === \'number\' ? v[i] : v[i] instanceof Array ? v[i][0] : v[i].split(/\\s/)[0]*1;\r\n        } else if (i === \'translate\'){\r\n          translation = v[i] instanceof Array ? v[i] : /\\,|\\s/.test(v[i]) ? v[i].split(\',\') : [v[i],0];\r\n          svgTransformObject[i] = [translation[0]*1||0, translation[1]*1||0];\r\n        } else if (/skew/.test(i)) {\r\n          svgTransformObject[i] = v[i]*1||0;\r\n        } else if (i === \'scale\'){\r\n          svgTransformObject[i] = parseFloat(v[i])||1;\r\n        }\r\n      }\r\n\r\n      return svgTransformObject;\r\n    };\r\n\r\n  parseProperty.svgTransform = function(p,v){\r\n    // register the render function\r\n    if (!(\'svgTransform\' in DOM)) {\r\n      DOM.svgTransform = function(l,p,a,b,v){\r\n        var x = 0, y = 0, tmp, deg = Math.PI/180,\r\n          scale = \'scale\' in b ? number(a.scale,b.scale,v) : 1,\r\n          rotate = \'rotate\' in b ? number(a.rotate,b.rotate,v) : 0,\r\n          sin = Math.sin(rotate*deg), cos = Math.cos(rotate*deg),\r\n          skewX = \'skewX\' in b ? number(a.skewX,b.skewX,v) : 0,\r\n          skewY = \'skewY\' in b ? number(a.skewY,b.skewY,v) : 0,\r\n          complex = rotate||skewX||skewY||scale!==1 || 0;\r\n\r\n        // start normalizing the translation, we start from last to first (from last chained translation)\r\n        // the normalized translation will handle the transformOrigin tween option and makes sure to have a consistent transformation\r\n        x -= complex ? b.origin[0] : 0; y -= complex ? b.origin[1] : 0; // we start with removing transformOrigin from translation\r\n        x *= scale; y *= scale; // we now apply the scale\r\n        y += skewY ? x*Math.tan(skewY*deg) : 0; x += skewX ? y*Math.tan(skewX*deg) : 0; // now we apply skews\r\n        tmp = cos*x - sin*y; // apply rotation as well\r\n        y = rotate ? sin*x + cos*y : y; x = rotate ? tmp : x;\r\n        x += \'translate\' in b ? number(a.translate[0],b.translate[0],v) : 0; // now we apply the actual translation\r\n        y += \'translate\' in b ? number(a.translate[1],b.translate[1],v) : 0;\r\n        x += complex ? b.origin[0] : 0; y += complex ? b.origin[1] : 0; // normalizing ends with the addition of the transformOrigin to the translation\r\n\r\n        // finally we apply the transform attribute value\r\n        l.setAttribute(\'transform\', ( x||y ? (\'translate(\' + (x*1000>>0)/1000 + ( y ? (\',\' + ((y*1000>>0)/1000)) : \'\') + \')\') : \'\' )\r\n                                    +( rotate ? \'rotate(\' + (rotate*1000>>0)/1000 + \')\' : \'\' )\r\n                                    +( skewX ? \'skewX(\' + (skewX*1000>>0)/1000 + \')\' : \'\' )\r\n                                    +( skewY ? \'skewY(\' + (skewY*1000>>0)/1000 + \')\' : \'\' )\r\n                                    +( scale !== 1 ? \'scale(\' + (scale*1000>>0)/1000 +\')\' : \'\' ) );\r\n      }\r\n    }\r\n\r\n    // now prepare transform\r\n    return parseTransformObject.call(this,v);\r\n  }\r\n\r\n  // returns an obect with current transform attribute value\r\n  prepareStart.svgTransform = function(p,t) {\r\n    var transformObject = {}, currentTransform = parseTransformString(this.element.getAttribute(\'transform\'));\r\n    for (var i in t) { transformObject[i] = i in currentTransform ? currentTransform[i] : (i===\'scale\'?1:0); } // find a value in current attribute value or add a default value\r\n    return transformObject;\r\n  }\r\n\r\n  crossCheck.svgTransform = function() { // helper function that helps preserve current transform properties into the objects\r\n    if (!this.options.rpr) return; // fix since 1.6.1 for fromTo() method\r\n    var valuesStart = this.valuesStart.svgTransform, valuesEnd = this.valuesEnd.svgTransform,\r\n      currentTransform = parseTransformObject.call(this, parseTransformString(this.element.getAttribute(\'transform\')) );\r\n\r\n    for ( var i in currentTransform ) { valuesStart[i] = currentTransform[i]; } // populate the valuesStart first\r\n\r\n    // now try to determine the REAL translation\r\n    var parentSVG = this.element.ownerSVGElement,\r\n      newTransform = parentSVG.createSVGTransformFromMatrix(\r\n        parentSVG.createSVGMatrix()\r\n        .translate(-valuesStart.origin[0],-valuesStart.origin[1]) // - origin\r\n        .translate(\'translate\' in valuesStart ? valuesStart.translate[0] : 0,\'translate\' in valuesStart ? valuesStart.translate[1] : 0) // the current translate\r\n        .rotate(valuesStart.rotate||0).skewX(valuesStart.skewX||0).skewY(valuesStart.skewY||0).scale(valuesStart.scale||1)// the other functions\r\n        .translate(+valuesStart.origin[0],+valuesStart.origin[1]) // + origin\r\n      );\r\n\r\n    valuesStart.translate = [newTransform.matrix.e,newTransform.matrix.f]; // finally the translate we\'re looking for\r\n\r\n    // copy existing and unused properties to the valuesEnd\r\n    for ( var i in valuesStart) { if ( !(i in valuesEnd)) { valuesEnd[i] = valuesStart[i]; } }\r\n  }\r\n\r\n  return this;\r\n}));\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:///./node_modules/kute.js/kute-svg.js?')},"./node_modules/kute.js/kute.js":/*!**************************************!*\
  !*** ./node_modules/kute.js/kute.js ***!
  \**************************************//*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* KUTE.js - The Light Tweening Engine\r\n * by dnp_theme\r\n * Licensed under MIT-License\r\n */\r\n(function (root,factory) {\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD. Register as an anonymous module.\r\n  } else {}\r\n}(this, function () {\r\n  "use strict";\r\n\r\n  // set a custom scope for KUTE.js\r\n  var g = typeof global !== \'undefined\' ? global : window, time = g.performance,\r\n    body = document.body, tweens = [], tick = null, // tick must be null!!\r\n\r\n    // strings\r\n    length = \'length\',\r\n    split = \'split\',\r\n    indexOf = \'indexOf\',\r\n    replace = \'replace\',\r\n\r\n    offsetWidth = \'offsetWidth\',\r\n    offsetHeight = \'offsetHeight\',\r\n\r\n    options = \'options\',\r\n    valuesStart = \'valuesStart\',\r\n    valuesEnd = \'valuesEnd\',\r\n    valuesRepeat = \'valuesRepeat\',\r\n\r\n    element = \'element\',\r\n    playing = \'playing\',\r\n\r\n    duration = \'duration\',\r\n    delay = \'delay\',\r\n    offset = \'offset\',\r\n    repeat = \'repeat\',\r\n    repeatDelay = \'repeatDelay\',\r\n    yoyo = \'yoyo\',\r\n    easing = \'easing\',\r\n    chain = \'chain\',\r\n    keepHex = \'keepHex\',\r\n\r\n    style = \'style\',\r\n    dataTweening = \'data-tweening\',\r\n    getElementsByTagName = \'getElementsByTagName\',\r\n    addEventListener = \'addEventListener\',\r\n    removeEventListener = \'removeEventListener\';\r\n\r\n\r\n  //supported properties\r\n  var colorProps = [\'color\', \'backgroundColor\'], // \'hex\', \'rgb\', \'rgba\' \'#fff\' \'rgb(0,0,0)\' / \'rgba(0,0,0,0)\' \'red\' (IE9+)\r\n    boxModelProps  = [\'top\', \'left\', \'width\', \'height\'], \r\n    transformFunctions  = [\'translate3d\', \'translateX\', \'translateY\', \'translateZ\', \'rotate\', \'translate\', \'rotateX\', \'rotateY\', \'rotateZ\', \'skewX\', \'skewY\', \'scale\'],\r\n    scrollProp  = [\'scroll\'], // has no default value, it\'s calculated on tween start\r\n    opacityProp  = [\'opacity\'], // opacity\r\n    coreProps = colorProps.concat( opacityProp, boxModelProps, transformFunctions),\r\n    defaultPropsValues = {}; \r\n\r\n  //populate default values object\r\n  for ( var propertyIndex=0, allCorePropLength = coreProps[length], coreProp; propertyIndex < allCorePropLength; propertyIndex++ ){\r\n    coreProp = coreProps[propertyIndex];\r\n    if (colorProps[indexOf](coreProp) !== -1){\r\n      defaultPropsValues[coreProp] = \'rgba(0,0,0,0)\'; // defaultPropsValues[coreProp] = {r:0,g:0,b:0,a:1};\r\n    } else if ( boxModelProps[indexOf](coreProp) !== -1 ) {\r\n      defaultPropsValues[coreProp] = 0;\r\n    } else if ( coreProp === \'translate3d\' ){ // px\r\n      defaultPropsValues[coreProp] = [0,0,0];\r\n    } else if ( coreProp === \'translate\' ){ // px\r\n      defaultPropsValues[coreProp] = [0,0];\r\n    } else if ( coreProp === \'rotate\' || /X|Y|Z/.test(coreProp) ){ // deg\r\n      defaultPropsValues[coreProp] = 0;\r\n    } else if ( coreProp === \'scale\' || coreProp === \'opacity\' ){ // unitless\r\n      defaultPropsValues[coreProp] = 1;\r\n    }\r\n  }\r\n\r\n  // default tween options, since 1.6.1\r\n  var defaultOptions = {\r\n      duration: 700,\r\n      delay: 0,\r\n      offset: 0,\r\n      repeat: 0,\r\n      repeatDelay: 0,\r\n      yoyo: false,\r\n      easing: \'linear\',\r\n      keepHex: false,\r\n    },\r\n    // tools / utils\r\n    getPrefix = function() { //returns browser prefix\r\n      var prefixes = [\'Moz\', \'moz\', \'Webkit\', \'webkit\', \'O\', \'o\', \'Ms\', \'ms\'], thePrefix;\r\n      for (var pIndex = 0, pfl = prefixes[length]; pIndex < pfl; pIndex++) { \r\n        if (prefixes[pIndex]+\'Transform\' in body[style]) { thePrefix = prefixes[pIndex]; break; }  \r\n      }\r\n      return thePrefix;\r\n    },\r\n    property = function(propertyToPrefix){ // returns prefixed property | property\r\n      var prefixRequired = (!(propertyToPrefix in body[style])) ? true : false, prefix = getPrefix(); // is prefix required for property | prefix\r\n      return prefixRequired ? prefix + (propertyToPrefix.charAt(0).toUpperCase() + propertyToPrefix.slice(1)) : propertyToPrefix;\r\n    },\r\n    selector = function(el,multi){ // a public selector utility\r\n      var requestedElem;\r\n      if (multi){\r\n        requestedElem = el instanceof Object || typeof el === \'object\' ? el : document.querySelectorAll(el);\r\n      } else {\r\n        requestedElem = typeof el === \'object\' ? el : document.querySelector(el);\r\n      }\r\n      if (requestedElem === null && el !== \'window\') throw new TypeError(\'Element not found or incorrect selector: \'+el);\r\n      return requestedElem;\r\n    },\r\n    radToDeg = function(a) { return a*180/Math.PI; },\r\n    trueDimension = function (dimValue,isAngle) { //true dimension returns { v = value, u = unit }\r\n      var intValue = parseInt(dimValue) || 0, mUnits = [\'px\',\'%\',\'deg\',\'rad\',\'em\',\'rem\',\'vh\',\'vw\'], theUnit;\r\n      for (var mIndex=0; mIndex<mUnits[length]; mIndex++) { \r\n        if ( typeof dimValue === \'string\' && dimValue[indexOf](mUnits[mIndex]) !== -1 ) { \r\n          theUnit = mUnits[mIndex]; break; \r\n        } \r\n      }\r\n      theUnit = theUnit !== undefined ? theUnit : (isAngle ? \'deg\' : \'px\');\r\n      return { v: intValue, u: theUnit };\r\n    },\r\n    trueColor = function (colorString) { // replace transparent and transform any color to rgba()/rgb()\r\n      if (/rgb|rgba/.test(colorString)) { // first check if it\'s a rgb string\r\n        var vrgb = colorString[replace](/\\s|\\)/,\'\')[split](\'(\')[1][split](\',\'), colorAlpha = vrgb[3] ? vrgb[3] : null;\r\n        if (!colorAlpha) {\r\n          return { r: parseInt(vrgb[0]), g: parseInt(vrgb[1]), b: parseInt(vrgb[2]) };\r\n        } else {\r\n          return { r: parseInt(vrgb[0]), g: parseInt(vrgb[1]), b: parseInt(vrgb[2]), a: parseFloat(colorAlpha) };\r\n        }\r\n      } else if (/^#/.test(colorString)) {\r\n        var fromHex = hexToRGB(colorString); return { r: fromHex.r, g: fromHex.g, b: fromHex.b };\r\n      } else if (/transparent|none|initial|inherit/.test(colorString)) {\r\n        return { r: 0, g: 0, b: 0, a: 0 };\r\n      } else if (!/^#|^rgb/.test(colorString) ) { // maybe we can check for web safe colors\r\n        var siteHead = document[getElementsByTagName](\'head\')[0]; siteHead[style].color = colorString;\r\n        var webColor = g.getComputedStyle(siteHead,null).color; webColor = /rgb/.test(webColor) ? webColor[replace](/[^\\d,]/g, \'\')[split](\',\') : [0,0,0];\r\n        siteHead[style].color = \'\'; return { r: parseInt(webColor[0]), g: parseInt(webColor[1]), b: parseInt(webColor[2]) };\r\n      }\r\n    },\r\n    rgbToHex = function (r, g, b) { // transform rgb to hex or vice-versa | webkit browsers ignore HEX, always use RGB/RGBA\r\n      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\r\n    },\r\n    hexToRGB = function (hex) {\r\n      var hexShorthand = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i; // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")\r\n      hex = hex[replace](hexShorthand, function (m, r, g, b) {\r\n        return r + r + g + g + b + b;\r\n      });\r\n      var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n      return result ? {\r\n        r: parseInt(result[1], 16),\r\n        g: parseInt(result[2], 16),\r\n        b: parseInt(result[3], 16)\r\n      } : null;\r\n    },\r\n    getInlineStyle = function(el) { // get transform style for element from cssText for .to() method\r\n      if (!el) return; // if the scroll applies to `window` it returns as it has no styling\r\n      var css = el[style].cssText[replace](/\\s/g,\'\')[split](\';\'), transformObject = {}; // the cssText | the resulting transform object\r\n\r\n      // if we have any inline style in the cssText attribute, usually it has higher priority\r\n      for ( var i=0, csl = css[length]; i<csl; i++ ){\r\n        if ( /transform/i.test(css[i])) {\r\n          var tps = css[i][split](\':\')[1][split](\')\'); //all transform properties\r\n          for ( var k=0, tpl = tps[length]-1; k< tpl; k++){\r\n            var tpv = tps[k][split](\'(\'), tp = tpv[0], tv = tpv[1]; // each transform property, the sp is for transform property\r\n            if ( transformFunctions[indexOf](tp) !== -1 ){\r\n              transformObject[tp] = /translate3d/.test(tp) ? tv[split](\',\') : tv;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return transformObject;\r\n    },\r\n    getCurrentStyle = function (elem,propertyName) { // get computed style property for element for .to() method\r\n      var styleAttribute = elem[style], computedStyle = g.getComputedStyle(elem,null) || elem.currentStyle, \r\n        prefixedProp = property(propertyName), //the computed style | prefixed property\r\n        styleValue = styleAttribute[propertyName] && !/auto|initial|none|unset/.test(styleAttribute[propertyName]) ? styleAttribute[propertyName] : computedStyle[prefixedProp];\r\n      if ( propertyName !== \'transform\' && (prefixedProp in computedStyle || prefixedProp in styleAttribute) ) {\r\n        if ( styleValue ){\r\n          if (prefixedProp === \'filter\') { // handle IE8 opacity\r\n            var filterValue = parseInt(styleValue[split](\'=\')[1][replace](\')\',\'\'));\r\n            return parseFloat(filterValue/100);\r\n          } else {\r\n            return styleValue;\r\n          }\r\n        } else {\r\n          return defaultPropsValues[propertyName];\r\n        }\r\n      }\r\n    },\r\n\r\n    //more internals\r\n    getAll = function () { return tweens; },\r\n    removeAll = function () { tweens = []; },\r\n    add = function (tw) { tweens.push(tw); },\r\n    remove = function (tw) { var i = tweens[indexOf](tw); if (i !== -1) { tweens.splice(i, 1); }},\r\n    stop = function () { if (tick) { _cancelAnimationFrame(tick); tick = null; } },\r\n\r\n    canTouch = (\'ontouchstart\' in g || navigator && navigator.msMaxTouchPoints) || false, // support Touch?\r\n    touchOrWheel = canTouch ? \'touchstart\' : \'mousewheel\', mouseEnter = \'mouseenter\', //events to prevent on scroll\r\n    _requestAnimationFrame = g.requestAnimationFrame || g.webkitRequestAnimationFrame || function (c) { return setTimeout(c, 16) },\r\n    _cancelAnimationFrame = g.cancelAnimationFrame || g.webkitCancelRequestAnimationFrame || function (c) { return clearTimeout(c) },\r\n    transformProperty = property(\'transform\'),\r\n\r\n    // true scroll container\r\n    html = document[getElementsByTagName](\'HTML\')[0],\r\n    // scrollContainer = navigator && /webkit/i.test(navigator.userAgent) || document.compatMode == \'BackCompat\' ? body : html,\r\n    scrollContainer = document.compatMode == \'BackCompat\' ? body : html, // webkit browsers are now srolling the HTML\r\n\r\n    // browser detection\r\n    isIE = navigator && (new RegExp("MSIE ([0-9]{1,}[\\.0-9]{0,})").exec(navigator.userAgent) !== null) ? parseFloat( RegExp.$1 ) : false,\r\n    isIE8 = isIE === 8, // check IE8/IE\r\n\r\n\r\n    // KUTE.js INTERPOLATORS\r\n    interpolate = g.Interpolate = {},\r\n    number = interpolate.number = function(a,b,v) { // number1, number2, progress\r\n      a = +a; b -= a; return a + b * v;\r\n    },\r\n    unit = interpolate.unit = function(a,b,u,v) { // number1, number2, unit, progress\r\n      a = +a; b -= a; return ( a + b * v ) + u;\r\n    },\r\n    color = interpolate.color = function(a,b,v,toHex){ // rgba1, rgba2, progress, convertToHex(true/false)\r\n      var _c = {}, c, ep = \')\', cm =\',\', rgb = \'rgb(\', rgba = \'rgba(\';\r\n      for (c in b) { _c[c] = c !== \'a\' ? (number(a[c],b[c],v)>>0 || 0) : (a[c] && b[c]) ? (number(a[c],b[c],v) * 100 >> 0 )/100 : null; }\r\n      return toHex ? rgbToHex( _c.r, _c.g, _c.b ) : !_c.a ? rgb + _c.r + cm + _c.g + cm + _c.b + ep : rgba + _c.r + cm + _c.g + cm + _c.b + cm + _c.a + ep;\r\n    },\r\n    translate = interpolate.translate = function (a,b,u,v){\r\n      var translation = {};\r\n      for (var ax in b){\r\n        translation[ax] = ( a[ax]===b[ax] ? b[ax] : ( (a[ax] + ( b[ax] - a[ax] ) * v ) * 1000 >> 0 ) / 1000 ) + u;\r\n      }\r\n      return translation.x||translation.y ? \'translate(\' + translation.x + \',\' + translation.y + \')\' :\r\n        \'translate3d(\' + translation.translateX + \',\' + translation.translateY + \',\' + translation.translateZ + \')\';\r\n    },\r\n    rotate = interpolate.rotate = function (a,b,u,v){\r\n      var rotation = {};\r\n      for ( var rx in b ){\r\n        rotation[rx] = rx === \'z\' ? (\'rotate(\'+ (((a[rx] + (b[rx] - a[rx]) * v) * 1000 >> 0 ) / 1000) + u + \')\')\r\n                                  : (rx + \'(\' + (((a[rx] + (b[rx] - a[rx]) * v) * 1000 >> 0 ) / 1000) + u + \')\');\r\n      }\r\n      return rotation.z ? rotation.z : (rotation.rotateX||\'\') + (rotation.rotateY||\'\') + (rotation.rotateZ||\'\');\r\n    },\r\n    skew = interpolate.skew = function (a,b,u,v){\r\n      var skewProp = {};\r\n      for ( var sx in b ){\r\n        skewProp[sx] = sx + \'(\' + (((a[sx] + (b[sx] - a[sx]) * v) * 1000 >> 0) / 1000) + u + \')\';\r\n      }\r\n      return (skewProp.skewX||\'\') + (skewProp.skewY||\'\');\r\n    },\r\n    scale = interpolate.scale = function(a,b,v){\r\n      return \'scale(\' + (((a + (b - a) * v) * 1000 >> 0 ) / 1000) + \')\';\r\n    },\r\n\r\n    // KUTE.js DOM update functions\r\n    DOM = {},\r\n    ticker = function(t) {\r\n      var i = 0;\r\n      while ( i < tweens[length] ) {\r\n        if ( update.call(tweens[i],t) ) {\r\n          i++;\r\n        } else {\r\n          tweens.splice(i, 1);\r\n        }\r\n      }\r\n      tick = _requestAnimationFrame(ticker);\r\n    },\r\n    update = function(t) {\r\n      t = t || time.now();\r\n      if ( t < this._startTime && this[playing] ) { return true; }\r\n\r\n      var elapsed = Math.min(( t - this._startTime ) / this[options][duration], 1), progress = this[options][easing](elapsed); // calculate progress\r\n\r\n      for (var tweenProp in this[valuesEnd]){ // render the DOM update\r\n        DOM[tweenProp](this[element],tweenProp,this[valuesStart][tweenProp],this[valuesEnd][tweenProp],progress,this[options]); \r\n      }\r\n\r\n      if (this[options].update) { this[options].update.call(); } // fire the updateCallback\r\n\r\n      if (elapsed === 1) {\r\n        if (this[options][repeat] > 0) {\r\n          if ( isFinite(this[options][repeat] ) ) { this[options][repeat]--; }\r\n\r\n          if (this[options][yoyo]) { // handle yoyo\r\n            this.reversed = !this.reversed;\r\n            reverse.call(this);\r\n          }\r\n\r\n          this._startTime = (this[options][yoyo] && !this.reversed) ? t + this[options][repeatDelay] : t; //set the right time for delay\r\n          return true;\r\n        } else {\r\n\r\n          if (this[options].complete) { this[options].complete.call(); }\r\n\r\n          scrollOut.call(this); // unbind preventing scroll when scroll tween finished\r\n\r\n          for (var i = 0, ctl = this[options][chain][length]; i < ctl; i++) { // start animating chained tweens\r\n            this[options][chain][i].start();\r\n          }\r\n\r\n          //stop ticking when finished\r\n          close.call(this);\r\n        }\r\n        return false;\r\n      }\r\n      return true;\r\n    },\r\n\r\n    // applies the transform origin and perspective\r\n    perspective = function () {\r\n      var el = this[element], ops = this[options];\r\n      if ( ops.perspective !== undefined && transformProperty in this[valuesEnd] ) { // element perspective\r\n        this[valuesStart][transformProperty][\'perspective\'] = this[valuesEnd][transformProperty][\'perspective\']; \r\n      }\r\n      // element transform origin / we filter it out for svgTransform to fix the Firefox transformOrigin bug https://bugzilla.mozilla.org/show_bug.cgi?id=923193\r\n      if ( ops.transformOrigin !== undefined && (!(\'svgTransform\' in this[valuesEnd])) ) { el[style][property(\'transformOrigin\')] = ops.transformOrigin; } // set transformOrigin for CSS3 transforms only\r\n      if ( ops.perspectiveOrigin !== undefined ) { el[style][property(\'perspectiveOrigin\')] = ops.perspectiveOrigin; } // element perspective origin\r\n      if ( ops.parentPerspective !== undefined ) { el.parentNode[style][property(\'perspective\')] = ops.parentPerspective + \'px\'; } // parent perspective\r\n      if ( ops.parentPerspectiveOrigin !== undefined ) { el.parentNode[style][property(\'perspectiveOrigin\')] = ops.parentPerspectiveOrigin; } // parent perspective origin\r\n    },\r\n\r\n    // plugin connector objects\r\n    prepareStart = {}, // check current property value when .to() method is used\r\n    crossCheck = {}, // checks for differences between start and end value, try to make sure start unit and end unit are same as well as consistent, stack transforms, process SVG paths\r\n\r\n    // parse properties object\r\n    // string parsing and property specific value processing\r\n    parseProperty = { // we already start working on core supported properties\r\n      boxModel : function(tweenProp,inputValue){\r\n        if (!(tweenProp in DOM)){\r\n          DOM[tweenProp] = function(elem,tweenProp,a,b,v){\r\n            elem[style][tweenProp] = ( v > 0.99 || v < 0.01 ? ((number(a,b,v)*10)>>0)/10 : (number(a,b,v) ) >> 0 ) + \'px\';\r\n          }\r\n        }\r\n        var boxValue = trueDimension(inputValue), offsetProp = tweenProp === \'height\' ? offsetHeight : offsetWidth;\r\n        return boxValue.u === \'%\' ? boxValue.v * this[element][offsetProp] / 100 : boxValue.v;\r\n      },\r\n      transform : function(tweenProp,inputValue) {\r\n        if (!(transformProperty in DOM)) {\r\n          DOM[transformProperty] = function(elem,tweenProp,a,b,v,o){\r\n            elem[style][tweenProp] = (a.perspective||\'\')\r\n              + (\'translate\' in a ? translate(a.translate,b.translate,\'px\',v):\'\')\r\n              + (\'rotate\' in a ? rotate(a.rotate,b.rotate,\'deg\',v):\'\')\r\n              + (\'skew\' in a ? skew(a.skew,b.skew,\'deg\',v):\'\')\r\n              + (\'scale\' in a ? scale(a.scale,b.scale,v):\'\');\r\n          }\r\n        }\r\n\r\n        // process each transform property\r\n        if (/translate/.test(tweenProp)) {\r\n          if (tweenProp === \'translate3d\') {\r\n            var t3d = inputValue[split](\',\'), t3d0 = trueDimension(t3d[0]), t3d1 = trueDimension(t3d[1], t3d2 = trueDimension(t3d[2]));\r\n            return {\r\n              translateX : t3d0.u === \'%\' ? (t3d0.v * this[element][offsetWidth] / 100) : t3d0.v,\r\n              translateY : t3d1.u === \'%\' ? (t3d1.v * this[element][offsetHeight] / 100) : t3d1.v,\r\n              translateZ : t3d2.u === \'%\' ? (t3d2.v * (this[element][offsetHeight] + this[element][offsetWidth]) / 200) : t3d2.v // to be changed with something like element and/or parent perspective\r\n            };\r\n          } else if (/^translate(?:[XYZ])$/.test(tweenProp)) {\r\n            var t1d = trueDimension(inputValue), percentOffset = /X/.test(tweenProp) ? this[element][offsetWidth] / 100 : /Y/.test(tweenProp) ? this[element][offsetHeight] / 100 : (this[element][offsetWidth]+this[element][offsetHeight]) / 200;\r\n\r\n            return t1d.u === \'%\' ? (t1d.v * percentOffset) : t1d.v;\r\n          } else if (tweenProp === \'translate\') {\r\n            var tv = typeof inputValue === \'string\' ? inputValue[split](\',\') : inputValue, t2d = {}, t2dv,\r\n              t2d0 = trueDimension(tv[0]), t2d1 = tv[length] ? trueDimension(tv[1]) : {v: 0, u: \'px\'};\r\n            if (tv instanceof Array) {\r\n              t2d.x = t2d0.u === \'%\' ? (t2d0.v * this[element][offsetWidth] / 100) : t2d0.v,\r\n              t2d.y = t2d1.u === \'%\' ? (t2d1.v * this[element][offsetHeight] / 100) : t2d1.v\r\n            } else {\r\n              t2dv = trueDimension(tv);\r\n              t2d.x = t2dv.u === \'%\' ? (t2dv.v * this[element][offsetWidth] / 100) : t2dv.v,\r\n              t2d.y = 0\r\n            }\r\n\r\n            return t2d;\r\n          }\r\n        } else if (/rotate|skew/.test(tweenProp)) {\r\n          if (/^rotate(?:[XYZ])$|skew(?:[XY])$/.test(tweenProp)) {\r\n            var r3d = trueDimension(inputValue,true);\r\n            return r3d.u === \'rad\' ? radToDeg(r3d.v) : r3d.v;\r\n          } else if (tweenProp === \'rotate\') {\r\n            var r2d = {}, r2dv = trueDimension(inputValue,true);\r\n            r2d.z = r2dv.u === \'rad\' ? radToDeg(r2dv.v) : r2dv.v;\r\n            return r2d;\r\n          }\r\n        } else if (tweenProp === \'scale\') {\r\n          return parseFloat(inputValue); // this must be parseFloat(v)\r\n        }\r\n      },\r\n      unitless : function(tweenProp,inputValue){  // scroll | opacity\r\n        if (/scroll/.test(tweenProp) && !(tweenProp in DOM) ){\r\n          DOM[tweenProp] = function(elem,tweenProp,a,b,v) {\r\n            elem.scrollTop = (number(a,b,v))>>0;\r\n          };\r\n        } else if (tweenProp === \'opacity\') {\r\n          if (!(tweenProp in DOM)) {\r\n            if (isIE8) {\r\n              DOM[tweenProp] = function(elem,tweenProp,a,b,v) {\r\n                var st = "alpha(opacity=", ep = \')\';\r\n                elem[style].filter = st + ((number(a,b,v) * 100)>>0) + ep;\r\n              };\r\n            } else {\r\n              DOM[tweenProp] = function(elem,tweenProp,a,b,v) {\r\n                elem[style].opacity = ((number(a,b,v) * 100)>>0)/100;\r\n              };\r\n            }\r\n          }\r\n        }\r\n        return parseFloat(inputValue);\r\n      },\r\n      colors : function(tweenProp,inputValue){ // colors\r\n        if (!(tweenProp in DOM)) {\r\n          DOM[tweenProp] = function(elem,tweenProp,a,b,v,o) {\r\n            elem[style][tweenProp] = color(a,b,v,o[keepHex]);\r\n          };\r\n        }\r\n        return trueColor(inputValue);\r\n      }\r\n    },\r\n\r\n    // process properties for endValues and startValues or one of them\r\n    preparePropertiesObject = function(obj, fn) { // this, props object, type: start/end\r\n      var propertiesObject = fn === \'start\' ? this[valuesStart] : this[valuesEnd],\r\n        skewObject = {}, rotateObject = {}, translateObject = {}, transformObject = {};\r\n\r\n      for (var x in obj) {\r\n        if (transformFunctions[indexOf](x) !== -1) { // transform object gets built here\r\n          var prepAxis = [\'X\', \'Y\', \'Z\']; //coordinates //   translate[x] = pp(x, obj[x]);\r\n          if ( /^translate(?:[XYZ]|3d)$/.test(x) ) { //process translate3d\r\n\r\n            for (var fnIndex = 0; fnIndex < 3; fnIndex++) {\r\n              var translateAxis = prepAxis[fnIndex];\r\n              if ( /3d/.test(x) ) {\r\n                translateObject[\'translate\' + translateAxis] = parseProperty.transform.call(this,\'translate\' + translateAxis, obj[x][fnIndex]);\r\n              } else {\r\n                translateObject[\'translate\' + translateAxis] = (\'translate\' + translateAxis in obj) ? parseProperty.transform.call(this,\'translate\' + translateAxis, obj[\'translate\' + translateAxis]) : 0;\r\n              }\r\n            }\r\n            transformObject[\'translate\'] = translateObject;\r\n          } else if ( /^rotate(?:[XYZ])$|^skew(?:[XY])$/.test(x) ) { //process rotation/skew\r\n            var objectName = /rotate/.test(x) ? \'rotate\' : \'skew\',\r\n              rotationOrSkew = objectName === \'rotate\' ? rotateObject : skewObject;\r\n            for (var rIndex = 0; rIndex < 3; rIndex++) {\r\n              var oneAxis = prepAxis[rIndex];\r\n              if ( obj[objectName+oneAxis] !== undefined && x !== \'skewZ\' ) {\r\n                rotationOrSkew[objectName+oneAxis] = parseProperty.transform.call(this,objectName+oneAxis, obj[objectName+oneAxis]);\r\n              }\r\n            }\r\n            transformObject[objectName] = rotationOrSkew;\r\n          } else if ( /(rotate|translate|scale)$/.test(x) ) { //process 2d translation / rotation\r\n            transformObject[x] = parseProperty.transform.call(this, x, obj[x]);\r\n          }\r\n          propertiesObject[transformProperty] = transformObject;\r\n        } else {\r\n          if ( boxModelProps[indexOf](x) !== -1 ) {\r\n            propertiesObject[x] = parseProperty.boxModel.call(this,x,obj[x]);\r\n          } else if (opacityProp[indexOf](x) !== -1 || x === \'scroll\') {\r\n            propertiesObject[x] = parseProperty.unitless.call(this,x,obj[x]);\r\n          } else if (colorProps[indexOf](x) !== -1) {\r\n            propertiesObject[x] = parseProperty.colors.call(this,x,obj[x]);\r\n          } else if (x in parseProperty) {  // or any other property from css/ attr / svg / third party plugins\r\n            propertiesObject[x] = parseProperty[x].call(this,x,obj[x]);\r\n          }\r\n        }\r\n      }\r\n    },\r\n    reverse = function () {\r\n      if (this[options][yoyo]) {\r\n        for (var reverseProp in this[valuesEnd]) {\r\n          var tmp = this[valuesRepeat][reverseProp];\r\n          this[valuesRepeat][reverseProp] = this[valuesEnd][reverseProp];\r\n          this[valuesEnd][reverseProp] = tmp;\r\n          this[valuesStart][reverseProp] = this[valuesRepeat][reverseProp];\r\n        }\r\n      }\r\n    },\r\n    close = function () { //  when animation is finished reset repeat, yoyo&reversed tweens\r\n      if (this[repeat] > 0) { this[options][repeat] = this[repeat]; }\r\n      if (this[options][yoyo] && this.reversed===true) { reverse.call(this); this.reversed = false; }\r\n      this[playing] = false;\r\n\r\n      !tweens[length] && stop();  // when all animations are finished, stop ticking after ~3 frames\r\n    },\r\n    preventScroll = function (eventObj) { // prevent mousewheel or touch events while tweening scroll\r\n      var data = body.getAttribute(dataTweening);\r\n      if (data && data === \'scroll\') { eventObj.preventDefault(); }\r\n    },\r\n    scrollOut = function(){ //prevent scroll when tweening scroll\r\n      if ( \'scroll\' in this[valuesEnd] && body.getAttribute(dataTweening)) {\r\n        body.removeAttribute(dataTweening);\r\n      }\r\n    },\r\n    scrollIn = function(){\r\n      if ( \'scroll\' in this[valuesEnd] && !body.getAttribute(dataTweening)) {\r\n        body.setAttribute(dataTweening, \'scroll\');\r\n      }\r\n    },\r\n    processEasing = function (fn) {\r\n      if ( typeof fn === \'function\') {\r\n        return fn;\r\n      } else if ( typeof fn === \'string\' ) {\r\n        return easingFn[fn]; // regular Robert Penner Easing Functions\r\n      }\r\n    },\r\n    getStartValues = function () { // stack transform props for .to() chains\r\n      var startValues = {}, currentStyle = getInlineStyle(this[element]),\r\n        degreeProps = [\'rotate\',\'skew\'], startAxis = [\'X\',\'Y\',\'Z\'];\r\n\r\n      for (var tweenProperty in this[valuesStart]){\r\n        if ( transformFunctions[indexOf](tweenProperty) !== -1 ) {\r\n          var r2d = (/(rotate|translate|scale)$/.test(tweenProperty));\r\n          if ( /translate/.test(tweenProperty) && tweenProperty !== \'translate\' ) {\r\n            startValues[\'translate3d\'] = currentStyle[\'translate3d\'] || defaultPropsValues[tweenProperty];\r\n          } else if ( r2d ) { // 2d transforms\r\n            startValues[tweenProperty] = currentStyle[tweenProperty] || defaultPropsValues[tweenProperty];\r\n          } else if ( !r2d && /rotate|skew/.test(tweenProperty) ) { // all angles\r\n            for (var degIndex=0; degIndex<2; degIndex++) {\r\n              for (var axisIndex = 0; axisIndex<3; axisIndex++) {\r\n                var s = degreeProps[degIndex]+startAxis[axisIndex];\r\n                if (transformFunctions[indexOf](s) !== -1 && (s in this[valuesStart]) ) { startValues[s] = currentStyle[s] || defaultPropsValues[s]; }\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          if ( tweenProperty !== \'scroll\' ) {\r\n            if (tweenProperty === \'opacity\' && isIE8 ) { // handle IE8 opacity\r\n              var currentOpacity = getCurrentStyle(this[element],\'filter\');\r\n              startValues[\'opacity\'] = typeof currentOpacity === \'number\' ? currentOpacity : defaultPropsValues[\'opacity\'];\r\n            } else {\r\n              if ( coreProps[indexOf](tweenProperty) !== -1 ) {\r\n                startValues[tweenProperty] = getCurrentStyle(this[element],tweenProperty) || d[tweenProperty];\r\n              } else { // plugins register here\r\n                startValues[tweenProperty] = tweenProperty in prepareStart ? prepareStart[tweenProperty].call(this,tweenProperty,this[valuesStart][tweenProperty]) : 0;\r\n              }\r\n            }\r\n          } else {\r\n            startValues[tweenProperty] = this[element] === scrollContainer ? (g.pageYOffset || scrollContainer.scrollTop) : this[element].scrollTop;\r\n          }\r\n        }\r\n      }\r\n      for ( var currentProperty in currentStyle ){ // also add to startValues values from previous tweens\r\n        if ( transformFunctions[indexOf](currentProperty) !== -1 && (!( currentProperty in this[valuesStart] )) ) {\r\n          startValues[currentProperty] = currentStyle[currentProperty] || defaultPropsValues[currentProperty];\r\n        }\r\n      }\r\n\r\n      this[valuesStart] = {};\r\n      preparePropertiesObject.call(this,startValues,\'start\');\r\n\r\n      if ( transformProperty in this[valuesEnd] ) { // let\'s stack transform\r\n        for ( var sp in this[valuesStart][transformProperty]) { // sp is the object corresponding to the transform function objects translate / rotate / skew / scale\r\n          if ( sp !== \'perspective\') {\r\n            if ( typeof this[valuesStart][transformProperty][sp] === \'object\' ) {\r\n              for ( var spp in this[valuesStart][transformProperty][sp] ) { // 3rd level\r\n                if ( typeof this[valuesEnd][transformProperty][sp] === \'undefined\' ) { this[valuesEnd][transformProperty][sp] = {}; }\r\n                if ( typeof this[valuesStart][transformProperty][sp][spp] === \'number\' && typeof this[valuesEnd][transformProperty][sp][spp] === \'undefined\' ) {\r\n                  this[valuesEnd][transformProperty][sp][spp] = this[valuesStart][transformProperty][sp][spp];\r\n                }\r\n              }\r\n            } else if ( typeof this[valuesStart][transformProperty][sp] === \'number\' ) {\r\n              if ( typeof this[valuesEnd][transformProperty][sp] === \'undefined\' ) { // scale\r\n                this[valuesEnd][transformProperty][sp] = this[valuesStart][transformProperty][sp];\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n  // core easing functions\r\n  var easingFn = g.Easing = {};\r\n  easingFn.linear = function (t) { return t; };\r\n  easingFn.easingSinusoidalIn = function(t) { return -Math.cos(t * Math.PI / 2) + 1; };\r\n  easingFn.easingSinusoidalOut = function(t) { return Math.sin(t * Math.PI / 2); };\r\n  easingFn.easingSinusoidalInOut = function(t) { return -0.5 * (Math.cos(Math.PI * t) - 1); };\r\n  easingFn.easingQuadraticIn = function (t) { return t*t; };\r\n  easingFn.easingQuadraticOut = function (t) { return t*(2-t); };\r\n  easingFn.easingQuadraticInOut = function (t) { return t<.5 ? 2*t*t : -1+(4-2*t)*t; };\r\n  easingFn.easingCubicIn = function (t) { return t*t*t; };\r\n  easingFn.easingCubicOut = function (t) { return (--t)*t*t+1; };\r\n  easingFn.easingCubicInOut = function (t) { return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1; };\r\n  easingFn.easingQuarticIn = function (t) { return t*t*t*t; };\r\n  easingFn.easingQuarticOut = function (t) { return 1-(--t)*t*t*t; };\r\n  easingFn.easingQuarticInOut = function (t) { return t<.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t; };\r\n  easingFn.easingQuinticIn = function (t) { return t*t*t*t*t; };\r\n  easingFn.easingQuinticOut = function (t) { return 1+(--t)*t*t*t*t; };\r\n  easingFn.easingQuinticInOut = function (t) { return t<.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t; };\r\n  easingFn.easingCircularIn = function(t) { return -(Math.sqrt(1 - (t * t)) - 1); };\r\n  easingFn.easingCircularOut = function(t) { return Math.sqrt(1 - (t = t - 1) * t); };\r\n  easingFn.easingCircularInOut = function(t) {  return ((t*=2) < 1) ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1); };\r\n  easingFn.easingExponentialIn = function(t) { return Math.pow(2, 10 * (t - 1)) - 0.001; };\r\n  easingFn.easingExponentialOut = function(t) { return 1 - Math.pow(2, -10 * t); };\r\n  easingFn.easingExponentialInOut = function(t) { return (t *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (t - 1)) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))); };\r\n  easingFn.easingBackIn = function(t) { var s = 1.70158; return t * t * ((s + 1) * t - s); };\r\n  easingFn.easingBackOut = function(t) { var s = 1.70158; return --t * t * ((s + 1) * t + s) + 1; };\r\n  easingFn.easingBackInOut = function(t) { var s = 1.70158 * 1.525;  if ((t *= 2) < 1) return 0.5 * (t * t * ((s + 1) * t - s));  return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2); };\r\n  easingFn.easingElasticIn = function(t) {\r\n    var s, _kea = 0.1, _kep = 0.4;\r\n    if ( t === 0 ) return 0; if ( t === 1 ) return 1;\r\n    if ( !_kea || _kea < 1 ) { _kea = 1; s = _kep / 4; } else s = _kep * Math.asin( 1 / _kea ) / Math.PI * 2;\r\n    return - ( _kea * Math.pow( 2, 10 * ( t -= 1 ) ) * Math.sin( ( t - s ) * Math.PI * 2 / _kep ) );\r\n  };\r\n  easingFn.easingElasticOut = function(t) {\r\n    var s, _kea = 0.1, _kep = 0.4;\r\n    if ( t === 0 ) return 0; if ( t === 1 ) return 1;\r\n    if ( !_kea || _kea < 1 ) { _kea = 1; s = _kep / 4; } else s = _kep * Math.asin( 1 / _kea ) / Math.PI * 2 ;\r\n    return ( _kea * Math.pow( 2, - 10 * t) * Math.sin( ( t - s ) * Math.PI * 2  / _kep ) + 1 );\r\n  };\r\n  easingFn.easingElasticInOut = function(t) {\r\n    var s, _kea = 0.1, _kep = 0.4;\r\n    if ( t === 0 ) return 0; if ( t === 1 ) return 1;\r\n    if ( !_kea || _kea < 1 ) { _kea = 1; s = _kep / 4; } else s = _kep * Math.asin( 1 / _kea ) / Math.PI * 2 ;\r\n    if ( ( t *= 2 ) < 1 ) return - 0.5 * ( _kea * Math.pow( 2, 10 * ( t -= 1 ) ) * Math.sin( ( t - s ) * Math.PI * 2  / _kep ) );\r\n    return _kea * Math.pow( 2, -10 * ( t -= 1 ) ) * Math.sin( ( t - s ) * Math.PI * 2  / _kep ) * 0.5 + 1;\r\n  };\r\n  easingFn.easingBounceIn = function(t) { return 1 - easingFn.easingBounceOut( 1 - t ); };\r\n  easingFn.easingBounceOut = function(t) {\r\n    if ( t < ( 1 / 2.75 ) ) { return 7.5625 * t * t; }\r\n    else if ( t < ( 2 / 2.75 ) ) { return 7.5625 * ( t -= ( 1.5 / 2.75 ) ) * t + 0.75; }\r\n    else if ( t < ( 2.5 / 2.75 ) ) { return 7.5625 * ( t -= ( 2.25 / 2.75 ) ) * t + 0.9375; }\r\n    else {return 7.5625 * ( t -= ( 2.625 / 2.75 ) ) * t + 0.984375; }\r\n  };\r\n  easingFn.easingBounceInOut = function(t) { if ( t < 0.5 ) return easingFn.easingBounceIn( t * 2 ) * 0.5; return easingFn.easingBounceOut( t * 2 - 1 ) * 0.5 + 0.5;};\r\n\r\n  // single Tween object construct\r\n  var Tween = function (targetElement, startObject, endObject, optionsObj) {\r\n      this[element] = \'scroll\' in endObject && (targetElement === undefined || targetElement === null) ? scrollContainer : targetElement; // element animation is applied to\r\n\r\n      this[playing] = false;\r\n      this.reversed = false;\r\n      this.paused = false;\r\n\r\n      this._startTime = null;\r\n      this._pauseTime = null;\r\n\r\n      this._startFired = false;\r\n      this[options] = {}; for (var o in optionsObj) { this[options][o] = optionsObj[o]; }\r\n      this[options].rpr = optionsObj.rpr || false; // internal option to process inline/computed style at start instead of init true/false\r\n\r\n      this[valuesRepeat] = {}; // internal valuesRepeat\r\n      this[valuesEnd] = {}; // valuesEnd\r\n      this[valuesStart] = {}; // valuesStart\r\n\r\n      preparePropertiesObject.call(this,endObject,\'end\'); // valuesEnd\r\n      if ( this[options].rpr ) { this[valuesStart] = startObject; } else { preparePropertiesObject.call(this,startObject,\'start\'); } // valuesStart\r\n\r\n      if ( this[options].perspective !== undefined && transformProperty in this[valuesEnd] ) { // element transform perspective\r\n        var perspectiveString = \'perspective(\'+parseInt(this[options].perspective)+\'px)\';\r\n        this[valuesEnd][transformProperty].perspective = perspectiveString;\r\n      }\r\n\r\n      for ( var repeatProp in this[valuesEnd] ) {\r\n        if (repeatProp in crossCheck && !this[options].rpr) crossCheck[repeatProp].call(this); // this is where we do the valuesStart and valuesEnd check for fromTo() method\r\n      }\r\n\r\n      this[options][chain] = []; // chained Tweens\r\n      this[options][easing] = processEasing(optionsObj[easing]) || easingFn[defaultOptions[easing]] || easingFn[\'linear\']; // you can only set a core easing function as default\r\n      this[options][repeat] = optionsObj[repeat] || defaultOptions[repeat];\r\n      this[options][repeatDelay] = optionsObj[repeatDelay] || defaultOptions[repeatDelay];\r\n      this[options][yoyo] = optionsObj[yoyo] || defaultOptions[yoyo];\r\n      this[options][duration] = optionsObj[duration] || defaultOptions[duration]; // duration option | default\r\n      this[options][delay] = optionsObj[delay] || defaultOptions[delay]; // delay option | default\r\n\r\n      this[repeat] = this[options][repeat]; // we cache the number of repeats to be able to put it back after all cycles finish\r\n    },\r\n    // tween control and chain\r\n    TweenProto = Tween.prototype = {\r\n      // queue tween object to main frame update\r\n      start : function (t) { // move functions that use the ticker outside the prototype to be in the same scope with it\r\n        scrollIn.call(this);\r\n\r\n        if ( this[options].rpr ) { getStartValues.apply(this); } // on start we reprocess the valuesStart for TO() method\r\n        perspective.apply(this); // apply the perspective and transform origin\r\n\r\n        for ( var endProp in this[valuesEnd] ) {\r\n          if (endProp in crossCheck && this[options].rpr) crossCheck[endProp].call(this); // this is where we do the valuesStart and valuesEnd check for to() method\r\n          this[valuesRepeat][endProp] = this[valuesStart][endProp];\r\n        }\r\n\r\n        // now it\'s a good time to start\r\n        tweens.push(this);\r\n        this[playing] = true;\r\n        this.paused = false;\r\n        this._startFired = false;\r\n        this._startTime = t || time.now();\r\n        this._startTime += this[options][delay];\r\n\r\n        if (!this._startFired) {\r\n          if (this[options].start) { this[options].start.call(); }\r\n          this._startFired = true;\r\n        }\r\n        !tick && ticker();\r\n        return this;\r\n      },\r\n      play : function () {\r\n        if (this.paused && this[playing]) {\r\n          this.paused = false;\r\n          if (this[options].resume) { this[options].resume.call(); }\r\n          this._startTime += time.now()  - this._pauseTime;\r\n          add(this);\r\n          !tick && ticker();  // restart ticking if stopped\r\n        }\r\n        return this;\r\n      },\r\n      resume : function () { return this.play(); },\r\n      pause : function() {\r\n        if (!this.paused && this[playing]) {\r\n          remove(this);\r\n          this.paused = true;\r\n          this._pauseTime = time.now();\r\n          if (this[options].pause) { this[options].pause.call(); }\r\n        }\r\n        return this;\r\n      },\r\n      stop : function () {\r\n        if (!this.paused && this[playing]) {\r\n          remove(this);\r\n          this[playing] = false;\r\n          this.paused = false;\r\n          scrollOut.call(this);\r\n\r\n          if (this[options].stop) { this[options].stop.call(); }\r\n          this.stopChainedTweens();\r\n          close.call(this);\r\n        }\r\n        return this;\r\n      },\r\n      chain : function() { this[options][chain] = arguments; return this; },\r\n      stopChainedTweens : function () {\r\n        for (var i = 0, ctl = this[options][chain][length]; i < ctl; i++) {\r\n          this[options][chain][i].stop();\r\n        }\r\n      }\r\n    },\r\n\r\n    // the multi elements Tween constructs\r\n    TweensTO = function (els, vE, o) { // .to\r\n      this.tweens = []; var optionsObj = [];\r\n      for ( var i = 0, tl = els[length]; i < tl; i++ ) {\r\n        optionsObj[i] = o || {}; o[delay] = o[delay] || defaultOptions[delay];\r\n        optionsObj[i][delay] = i>0 ? o[delay] + (o[offset]||defaultOptions[offset]) : o[delay];\r\n        this.tweens.push( to(els[i], vE, optionsObj[i]) );\r\n      }\r\n    },\r\n    TweensFT = function (els, vS, vE, o) { // .fromTo\r\n      this.tweens = []; var optionsObj = [];\r\n      for ( var i = 0, l = els[length]; i < l; i++ ) {\r\n        optionsObj[i] = o || {}; o[delay] = o[delay] || defaultOptions[delay];\r\n        optionsObj[i][delay] = i>0 ? o[delay] + (o[offset]||defaultOptions[offset]) : o[delay];\r\n        this.tweens.push( fromTo(els[i], vS, vE, optionsObj[i]) );\r\n      }\r\n    },\r\n    ws = TweensTO.prototype = TweensFT.prototype = {\r\n      start : function(t){\r\n        t = t || time.now();\r\n        for ( var i = 0, tl = this.tweens[length]; i < tl; i++ ) {\r\n          this.tweens[i].start(t);\r\n        }\r\n        return this;\r\n      },\r\n      stop : function(){ for ( var i = 0, tl = this.tweens[length]; i < tl; i++ ) { this.tweens[i].stop(); } return this; },\r\n      pause : function(){ for ( var i = 0, tl = this.tweens[length]; i < tl; i++ ) { this.tweens[i].pause(); } return this; },\r\n      chain : function(){ this.tweens[this.tweens[length]-1][options][chain] = arguments; return this; },\r\n      play : function(){ for ( var i = 0, tl = this.tweens[length]; i < tl; i++ ) { this.tweens[i].play(); } return this; },\r\n      resume : function() {return this.play()}\r\n    },\r\n\r\n    // main methods\r\n    to = function (element, endObject, optionsObj) {\r\n      optionsObj = optionsObj || {}; optionsObj.rpr = true;\r\n      return new Tween(selector(element), endObject, endObject, optionsObj);\r\n    },\r\n    fromTo = function (element, startObject, endObject, optionsObj) {\r\n      optionsObj = optionsObj || {};\r\n      return new Tween(selector(element), startObject, endObject, optionsObj);\r\n    },\r\n\r\n    // multiple elements tweening\r\n    allTo = function (elements, endObject, optionsObj) {\r\n      return new TweensTO(selector(elements,true), endObject, optionsObj);\r\n    },\r\n    allFromTo = function (elements, startObject, endObject, optionsObj) {\r\n      return new TweensFT(selector(elements,true), startObject, endObject, optionsObj);\r\n    };\r\n\r\n  document[addEventListener](touchOrWheel, preventScroll, false);\r\n  document[addEventListener](mouseEnter, preventScroll, false);\r\n\r\n  return { // export core methods to public for plugins\r\n    property: property, getPrefix: getPrefix, selector: selector, processEasing : processEasing, // utils\r\n    defaultOptions : defaultOptions, // default tween options since 1.6.1\r\n    to: to, fromTo: fromTo, allTo: allTo, allFromTo: allFromTo, // main methods\r\n    ticker : ticker, tick : tick, tweens : tweens, update: update, dom : DOM, // update\r\n    parseProperty: parseProperty, prepareStart: prepareStart, crossCheck : crossCheck, Tween : Tween, // property parsing & preparation | Tween | crossCheck\r\n    truD: trueDimension, truC: trueColor, rth: rgbToHex, htr: hexToRGB, getCurrentStyle: getCurrentStyle, // property parsing\r\n  };\r\n}));\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:///./node_modules/kute.js/kute.js?')},"./node_modules/webpack/buildin/global.js":/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************//*! no static exports found */function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1, eval)("this");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === "object") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},"./src/css/style.css":/*!***************************!*\
  !*** ./src/css/style.css ***!
  \***************************//*! no static exports found */function(module,exports){eval('module.exports = "C:\\\\Users\\\\kcantrell\\\\Desktop\\\\offline-dev-projects\\\\projects-git-staging\\\\pomodoro-clockdist/style.css";\n\n//# sourceURL=webpack:///./src/css/style.css?')},"./src/js/Timer.js":/*!*************************!*\
  !*** ./src/js/Timer.js ***!
  \*************************//*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Timer = function () {\n  function Timer(_ref) {\n    var minutesEl = _ref.minutesEl,\n        secondsEl = _ref.secondsEl,\n        messageEl = _ref.messageEl,\n        animator = _ref.animator;\n\n    _classCallCheck(this, Timer);\n\n    this.deps = {\n      animator: animator\n    }, this.minutesEl = minutesEl;\n    this.secondsEl = secondsEl;\n    this.messageEl = messageEl;\n    this.inProgress = false;\n    this.memory = 0;\n    this.minutesRemaining = 0;\n    this.seconds = 60;\n    this.minutesElapsed = 0;\n  }\n\n  _createClass(Timer, [{\n    key: "run",\n    value: function run() {\n      this.toggleInProgress();\n      this.toggleMessage();\n      this.minutesElapsed = 0;\n      this.minutesRemaining = this.getNumFromView(this.minutesEl) <= 0 ? this.memory : this.getNumFromView(this.minutesEl);\n      this.memory = this.minutesRemaining;\n      if (this.minutesRemaining > 0) {\n        this.countMinutesDown();\n        this.countSecondsDown();\n        this.secondsInterval = setInterval(this.countSecondsDown.bind(this), 1000);\n      }\n    }\n  }, {\n    key: "toggleInProgress",\n    value: function toggleInProgress() {\n      if (this.inProgress) {\n        this.inProgress = false;\n      } else {\n        this.inProgress = true;\n      }\n    }\n  }, {\n    key: "toggleMessage",\n    value: function toggleMessage() {\n      this.messageEl.classList.toggle("message--hidden");\n    }\n  }, {\n    key: "countSecondsDown",\n    value: function countSecondsDown() {\n      this.seconds -= 1;\n      if (this.seconds.toString().length < 2) {\n        this.secondsEl.textContent = ":0" + this.seconds;\n      } else {\n        this.secondsEl.textContent = ":" + this.seconds;\n      }\n      if (this.seconds === 0) {\n        this.minutesElapsed += 1;\n        this.countMinutesDown();\n        this.seconds = 60;\n      }\n      if (this.minutesElapsed === this.memory) {\n        clearInterval(this.secondsInterval);\n      }\n    }\n  }, {\n    key: "reset",\n    value: function reset() {\n      if (this.inProgress) {\n        this.toggleInProgress();\n        this.minutesRemaining = this.memory;\n        this.minutesEl.textContent = this.minutesRemaining > 0 && !isNaN(this.minutesRemaining) ? this.minutesRemaining : "Set Break Time";\n        this.seconds = 60;\n        this.secondsEl.textContent = ":00";\n        this.toggleMessage();\n      } else {\n        this.minutesEl.textContent = this.memory > 0 ? this.memory : "Set Break Time";\n      }\n      if (this.secondsInterval) {\n        clearInterval(this.secondsInterval);\n      }\n    }\n  }, {\n    key: "increment",\n    value: function increment() {\n      var minsFromView = this.getNumFromView(this.minutesEl);\n      if (this.secondsEl.textContent === \'\') {\n        this.secondsEl.textContent = ":00";\n      }\n      var temp = isNaN(minsFromView) ? 0 : minsFromView;\n      temp++;\n      this.minutesRemaining = temp;\n      this.memory = temp;\n      this.minutesEl.textContent = this.minutesRemaining;\n    }\n  }, {\n    key: "decrement",\n    value: function decrement() {\n      var minsFromView = this.getNumFromView(this.minutesEl);\n      if (minsFromView > 1 && !isNaN(minsFromView)) {\n        if (this.seconds.textContent === \'\') {\n          this.seconds.textContent = ":00";\n        }\n        var temp = minsFromView;\n        temp--;\n        this.minutesRemaining = temp;\n        this.memory = temp;\n        this.minutesEl.textContent = this.minutesRemaining;\n      }\n    }\n  }, {\n    key: "getNumFromView",\n    value: function getNumFromView(viewEl) {\n      return parseInt(viewEl.textContent);\n    }\n  }, {\n    key: "isReady",\n    value: function isReady() {\n      return !this.inProgress && this.memory > 0;\n    }\n  }]);\n\n  return Timer;\n}();\n\n/* harmony default export */ __webpack_exports__["default"] = (Timer);\n\n//# sourceURL=webpack:///./src/js/Timer.js?')},"./src/js/animator.js":/*!****************************!*\
  !*** ./src/js/animator.js ***!
  \****************************//*! exports provided: animator */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animator", function() { return animator; });\n/* harmony import */ var kute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! kute.js */ "./node_modules/kute.js/kute.js");\n/* harmony import */ var kute_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(kute_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var kute_js_kute_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! kute.js/kute-svg */ "./node_modules/kute.js/kute-svg.js");\n/* harmony import */ var kute_js_kute_svg__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(kute_js_kute_svg__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var kute_js_kute_attr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! kute.js/kute-attr */ "./node_modules/kute.js/kute-attr.js");\n/* harmony import */ var kute_js_kute_attr__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(kute_js_kute_attr__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nvar animator = {\n  deps: {\n    view: \'\'\n  },\n  triangle: \'\',\n  circle: \'\',\n  line: \'\',\n  init: function init(_ref) {\n    var initTime = _ref.initTime,\n        view = _ref.view;\n\n    this.deps.view = view;\n    this.deps.view.triangle.setAttribute("transform", "rotate(0 290 4)");\n    this.deps.view.circle.style["stroke-dasharray"] = 0;\n    this.deps.view.circle.setAttribute("stroke", "rgba(71, 61, 255, 0.47)");\n    this.deps.view.line.setAttribute("stroke", "rgba(184, 184, 184, 0.79)");\n    this.setTweens(initTime);\n  },\n\n  reset: function reset() {\n    this.triangle.stop();\n    this.circle.stop();\n    this.line.stop();\n    this.deps.view.triangle.setAttribute("transform", "rotate(0 290 4)");\n    this.deps.view.circle.style["stroke-dasharray"] = 0;\n    this.deps.view.circle.setAttribute("stroke", "rgba(71, 61, 255, 0.47)");\n    this.deps.view.line.setAttribute("stroke", "rgba(184, 184, 184, 0.79)");\n  },\n  play: function play(minutes) {\n    this.setTweens(minutes);\n    this.triangle.start();\n    this.circle.start();\n    this.line.start();\n  },\n  reverse: function reverse(minutes) {\n    this.triangle.stop();\n    this.circle.stop();\n    this.line.stop();\n\n    var ms = minutes * 60000;\n    this.triangle = kute_js__WEBPACK_IMPORTED_MODULE_0___default.a.fromTo(this.deps.view.triangle, { svgTransform: { rotate: 360 } }, { svgTransform: { rotate: 0 } }, { duration: ms, easing: "easingCubicOut" });\n    this.circle = kute_js__WEBPACK_IMPORTED_MODULE_0___default.a.fromTo(this.deps.view.circle, { draw: "0% 0%", attr: { stroke: "rgba(214, 214, 214, 0.76)" } }, { draw: "0% 100%", attr: { stroke: "rgba(71, 61, 255, 0.47)" } }, { duration: ms < 60000 ? ms : 60000, repeat: minutes - 1 });\n    this.line = kute_js__WEBPACK_IMPORTED_MODULE_0___default.a.fromTo(this.deps.view.line, { attr: { stroke: "rgba(71, 61, 255, 0.47)" } }, { attr: { stroke: "rgba(184, 184, 184, 0.79)" } }, { duration: 1000, repeat: ms / 1000 - 3, yoyo: true });\n\n    this.triangle.start();\n    this.circle.start();\n    this.line.start();\n  },\n  setTweens: function setTweens(minutes) {\n    var ms = minutes * 60000;\n    this.triangle = kute_js__WEBPACK_IMPORTED_MODULE_0___default.a.fromTo(this.deps.view.triangle, { svgTransform: { rotate: 0 } }, { svgTransform: { rotate: 360 } }, { duration: ms, easing: "easingCubicOut" });\n    this.circle = kute_js__WEBPACK_IMPORTED_MODULE_0___default.a.fromTo(this.deps.view.circle, { draw: "0% 100%", attr: { stroke: "rgba(71, 61, 255, 0.47)" } }, { draw: "0% 0%", attr: { stroke: "rgba(214, 214, 214, 0.76)" } }, { duration: ms < 60000 ? ms : 60000, repeat: minutes - 1 });\n    this.line = kute_js__WEBPACK_IMPORTED_MODULE_0___default.a.fromTo(this.deps.view.line, { attr: { stroke: "rgba(184, 184, 184, 0.79)" } }, { attr: { stroke: "rgba(71, 61, 255, 0.47)" } }, { duration: 1000, repeat: ms / 1000 - 3, yoyo: true });\n  }\n};\n\n\n\n//# sourceURL=webpack:///./src/js/animator.js?')},"./src/js/index.js":/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************//*! no exports provided */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view */ "./src/js/view.js");\n/* harmony import */ var _animator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./animator */ "./src/js/animator.js");\n/* harmony import */ var _Timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Timer */ "./src/js/Timer.js");\n/* harmony import */ var _css_style_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css/style.css */ "./src/css/style.css");\n/* harmony import */ var _css_style_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_css_style_css__WEBPACK_IMPORTED_MODULE_3__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n_view__WEBPACK_IMPORTED_MODULE_0__["view"].cacheDom();\n\nvar MainTimer = function (_Timer) {\n  _inherits(MainTimer, _Timer);\n\n  function MainTimer(_ref) {\n    var minutesEl = _ref.minutesEl,\n        secondsEl = _ref.secondsEl,\n        messageEl = _ref.messageEl,\n        animator = _ref.animator,\n        breakTimer = _ref.breakTimer;\n\n    _classCallCheck(this, MainTimer);\n\n    var _this = _possibleConstructorReturn(this, (MainTimer.__proto__ || Object.getPrototypeOf(MainTimer)).call(this, { minutesEl: minutesEl, secondsEl: secondsEl, messageEl: messageEl, animator: animator }));\n\n    _this.deps.breakTimer = breakTimer;\n    return _this;\n  }\n\n  _createClass(MainTimer, [{\n    key: \'init\',\n    value: function init(initValue) {\n      this.memory = initValue;\n      this.minutesRemaining = initValue;\n    }\n  }, {\n    key: \'countMinutesDown\',\n    value: function countMinutesDown() {\n      if (this.minutesRemaining > 0) {\n        this.minutesRemaining -= 1;\n        this.minutesEl.textContent = this.minutesRemaining;\n      } else {\n        this.toggleInProgress();\n        this.toggleMessage();\n        if (this.deps.breakTimer.minutesRemaining > 0) {\n          this.deps.animator.reverse(this.deps.breakTimer.minutesRemaining);\n          this.deps.breakTimer.run();\n        } else {\n          this.deps.animator.reset();\n        }\n      }\n    }\n  }, {\n    key: \'setPreset\',\n    value: function setPreset(time) {\n      this.memory = time;\n      this.minutesEl.textContent = time;\n    }\n  }]);\n\n  return MainTimer;\n}(_Timer__WEBPACK_IMPORTED_MODULE_2__["default"]);\n\nvar BreakTimer = function (_Timer2) {\n  _inherits(BreakTimer, _Timer2);\n\n  function BreakTimer(_ref2) {\n    var minutesEl = _ref2.minutesEl,\n        secondsEl = _ref2.secondsEl,\n        messageEl = _ref2.messageEl,\n        animator = _ref2.animator;\n\n    _classCallCheck(this, BreakTimer);\n\n    return _possibleConstructorReturn(this, (BreakTimer.__proto__ || Object.getPrototypeOf(BreakTimer)).call(this, { minutesEl: minutesEl, secondsEl: secondsEl, messageEl: messageEl, animator: animator }));\n  }\n\n  _createClass(BreakTimer, [{\n    key: \'countMinutesDown\',\n    value: function countMinutesDown() {\n      if (this.minutesRemaining > 0) {\n        this.minutesRemaining -= 1;\n        this.minutesEl.textContent = this.minutesRemaining;\n      } else {\n        this.toggleInProgress();\n        this.toggleMessage();\n      }\n    }\n  }, {\n    key: \'decrement\',\n    value: function decrement() {\n      var minsFromView = this.getNumFromView(this.minutesEl);\n      if (minsFromView > 1 && !isNaN(minsFromView)) {\n        if (this.seconds.textContent === \'\') {\n          this.seconds.textContent = ":00";\n        }\n        var temp = minsFromView;\n        temp--;\n        this.minutesRemaining = temp;\n        this.memory = temp;\n        this.minutesEl.textContent = this.minutesRemaining;\n      } else {\n        this.memory = 0;\n        this.minutesEl.textContent = "Set Break Time";\n        this.secondsEl.textContent = \'\';\n      }\n    }\n  }, {\n    key: \'isReady\',\n    value: function isReady() {\n      return !this.inProgress;\n    }\n  }]);\n\n  return BreakTimer;\n}(_Timer__WEBPACK_IMPORTED_MODULE_2__["default"]);\n\nvar breakTimer = new BreakTimer({\n  minutesEl: _view__WEBPACK_IMPORTED_MODULE_0__["view"].breakMinutes,\n  secondsEl: _view__WEBPACK_IMPORTED_MODULE_0__["view"].breakSeconds,\n  messageEl: _view__WEBPACK_IMPORTED_MODULE_0__["view"].breakMessage,\n  animator: _animator__WEBPACK_IMPORTED_MODULE_1__["animator"]\n});\n\nvar mainTimer = new MainTimer({\n  minutesEl: _view__WEBPACK_IMPORTED_MODULE_0__["view"].minutes,\n  secondsEl: _view__WEBPACK_IMPORTED_MODULE_0__["view"].seconds,\n  messageEl: _view__WEBPACK_IMPORTED_MODULE_0__["view"].workMessage,\n  animator: _animator__WEBPACK_IMPORTED_MODULE_1__["animator"],\n  breakTimer: breakTimer\n});\n\nvar initMainTimerMinutes = 25;\n\n_view__WEBPACK_IMPORTED_MODULE_0__["view"].injectDependencies({ mainTimer: mainTimer, breakTimer: breakTimer, animator: _animator__WEBPACK_IMPORTED_MODULE_1__["animator"] });\nmainTimer.init(initMainTimerMinutes);\n_animator__WEBPACK_IMPORTED_MODULE_1__["animator"].init({ initMainTimerMinutes: initMainTimerMinutes, view: _view__WEBPACK_IMPORTED_MODULE_0__["view"] });\n\n//# sourceURL=webpack:///./src/js/index.js?')},"./src/js/view.js":/*!************************!*\
  !*** ./src/js/view.js ***!
  \************************//*! exports provided: view */function(module,__webpack_exports__,__webpack_require__){'use strict';eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "view", function() { return view; });\nvar view = {\n  deps: {\n    mainTimer: \'\',\n    breakTimer: \'\',\n    animator: \'\'\n  },\n  rootEl: document.getElementById(\'pomodoro\'),\n  injectDependencies: function injectDependencies(_ref) {\n    var mainTimer = _ref.mainTimer,\n        breakTimer = _ref.breakTimer,\n        animator = _ref.animator;\n\n    this.deps.mainTimer = mainTimer;\n    this.deps.breakTimer = breakTimer;\n    this.deps.animator = animator;\n    this.bindEvents();\n  },\n  cacheDom: function cacheDom() {\n    this.activate = this.rootEl.querySelector("#activate"), this.triangle = this.rootEl.querySelector("#triangle"), this.circle = this.rootEl.querySelector("#circle"), this.line = this.rootEl.querySelector("#line"), this.tenSecs = this.rootEl.querySelector("#ten"), this.hundredTwentySecs = this.rootEl.querySelector("#hundred-twenty"), this.reset = this.rootEl.querySelector("#reset"), this.minutes = this.rootEl.querySelector("#minutes"), this.seconds = this.rootEl.querySelector("#seconds"), this.breakMinutes = this.rootEl.querySelector("#break-minutes"), this.breakSeconds = this.rootEl.querySelector("#break-seconds"), this.btns = this.rootEl.querySelectorAll(".btn"), this.breakBtns = this.rootEl.querySelectorAll(".break-clock__adjuster"), this.workMessage = this.rootEl.querySelector("#work-message"), this.breakMessage = this.rootEl.querySelector("#break-message"), this.adder = this.rootEl.querySelector("#adder"), this.subtracter = this.rootEl.querySelector("#subtracter"), this.breakAdder = this.rootEl.querySelector("#break-adder"), this.breakSubtracter = this.rootEl.querySelector("#break-subtracter");\n  },\n  bindEvents: function bindEvents() {\n    var _this = this;\n    this.activate.addEventListener("click", function () {\n      if (_this.deps.mainTimer.isReady() && _this.deps.breakTimer.isReady()) {\n        _this.deps.breakTimer.reset();\n        _this.deps.animator.play(_this.deps.mainTimer.memory);\n        _this.deps.mainTimer.run();\n      }\n    });\n    this.tenSecs.addEventListener("click", function () {\n      _this.deps.animator.reset();\n      _this.deps.mainTimer.reset();\n      _this.deps.breakTimer.reset();\n      _this.deps.mainTimer.setPreset(10);\n    });\n    this.hundredTwentySecs.addEventListener("click", function () {\n      _this.deps.animator.reset();\n      _this.deps.mainTimer.reset();\n      _this.deps.breakTimer.reset();\n      _this.deps.mainTimer.setPreset(25);\n    });\n    this.reset.addEventListener("click", function () {\n      _this.deps.animator.reset();\n      _this.deps.mainTimer.reset();\n      _this.deps.breakTimer.reset();\n    });\n    this.adder.addEventListener("click", function () {\n      _this.deps.mainTimer.reset();\n      _this.deps.mainTimer.increment();\n      _this.deps.animator.reset();\n    });\n    this.subtracter.addEventListener("click", function () {\n      _this.deps.mainTimer.reset();\n      _this.deps.mainTimer.decrement();\n      _this.deps.animator.reset();\n    });\n    this.breakAdder.addEventListener("click", function () {\n      _this.deps.mainTimer.reset();\n      _this.deps.breakTimer.reset();\n      _this.deps.breakTimer.increment();\n      _this.deps.animator.reset();\n    });\n    this.breakSubtracter.addEventListener("click", function () {\n      _this.deps.mainTimer.reset();\n      _this.deps.breakTimer.reset();\n      _this.deps.breakTimer.decrement();\n      _this.deps.animator.reset();\n    });\n  }\n};\n\n\n\n//# sourceURL=webpack:///./src/js/view.js?')}});